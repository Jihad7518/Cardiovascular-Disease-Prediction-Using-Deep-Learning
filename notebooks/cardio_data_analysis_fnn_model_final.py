# -*- coding: utf-8 -*-
"""cardio_data_analysis_FNN_Model_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AA2TF-B4N3RWoR97xUCLQw9RrAqVa47Q

<h1>Cardiovasculer Disease Prediction Machine Learning Project </h1>
<h2>Predicting  Cardiovascular Disease Using a cutting-edge Deep Learning Technique </h2>
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings('ignore')

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, KFold
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import classification_report
from scipy.stats import chi2_contingency

from sklearn.svm import SVC

df=pd.read_csv('heart_data.csv')
df.head()

df.tail(20)

"""<h1>Data Information, Cleaning & Visualization</h1>

Age : Age of participant (integer)

Gender : Gender of participant (male/female).

Height : Height measured in centimeters (integer)

Weight : Weight measured in kilograms (integer)

Ap_hi : Systolic blood pressure reading taken from patient (integer)

Ap_lo : Diastolic blood pressure reading taken from patient (integer)

Cholesterol : Total cholesterol level read as mg/dl on a scale 0 - 5+ units (integer). Each unit denoting increase/decrease by 20 mg/dL respectively.

Gluc : Glucose level read as mmol/l on a scale 0 - 16+ units (integer). Each unit denoting increase Decreaseby 1 mmol/L respectively.

Smoke : Whether person smokes or not(binary; 0=No , 1=Yes).

Alco : Whether person drinks alcohol or not(binary; 0=No ,1=Yes).

Active : whether person physically active or not( Binary ; 0=No,1=Yes).

Cardio : whether person suffers from cardiovascular diseases or not(Binary; 0=No , 1=Yes).
"""

df.info()

df.dtypes

df.size

df.shape

df.columns

df.drop(['index', 'id'], axis = 1, inplace = True)
df['age']=(df['age']/365).astype(int)
df

df.columns

df.isnull().sum()

df.nunique()

sns.heatmap(df.isnull(), cmap="RdPu" );

df.describe().T

df_corr = df.corr()
df_corr

plt.figure(figsize=(10, 10))
correlation=df.corr(numeric_only=True)
sns.heatmap(correlation, annot=True, cmap='RdPu')
plt.tight_layout()

df['cardio'].value_counts()

plt.figure(figsize = (5, 5))
plt.title('Cardiovascular Disease Percentage ')
plt.pie(df['cardio'].value_counts(), labels = ['No Cardiovascular Disease', 'Cardiovascular Disease'], explode = (0.0, 0.05), colors = ['salmon', 'red'],autopct = '%1.2f%%', shadow = False)
plt.legend(loc = 'best');

plt.figure(figsize=(10, 6))
plt.hist(df[df['cardio'] == 0]['age'], bins=20, color='blue', alpha=0.5, label='Cardio 0')
plt.hist(df[df['cardio'] == 1]['age'], bins=20, color='red', alpha=0.5, label='Cardio 1')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.title('Distribution of Cardio Risk by Age')
plt.legend()
plt.show()

sea = sns.FacetGrid(data=df, hue="cardio", height=5)
sea.map(sns.distplot, "age").add_legend()

df['gender'].replace({1: 'Male', 2: 'female'}, inplace=True)
df['cardio'].replace({0:'No Cardio', 1:'With Cardio'}, inplace=True)

gender_counts = df['gender'].value_counts()
gender_counts

sea = sns.FacetGrid(data=df, hue="cardio", height=4)
sea.map(sns.histplot, "gender", shrink=0.8, alpha=0.5)
sea.add_legend()

sea = sns.FacetGrid(data=df, hue="cardio", height=5)
sea.map(sns.distplot, "weight")
sea.add_legend()

sea = sns.FacetGrid(data=df, hue="cardio", height=5)
sea.map(sns.distplot, "height")
sea.add_legend()

# df['cholesterol']=df['cholesterol'].replace({1: 'normal', 2: 'above normal', 3: 'well above normal' })
# cholesterol_counts2 = df['cholesterol'].value_counts()
# cholesterol_counts2

# Create a new column 'cholesterol_transformed' with the mapped values
df['cholesterol_transformed'] = df['cholesterol'].replace({1: 'normal', 2: 'above normal', 3: 'well above normal'})

# Count the values in the new column
cholesterol_counts2 = df['cholesterol_transformed'].value_counts()
print(cholesterol_counts2)

# Check for unique values in the original 'cholesterol' column
unique_cholesterol_values = df['cholesterol'].unique()
print(unique_cholesterol_values)

sea = sns.FacetGrid(data=df, hue="cardio", height=5)
sea.map(sns.histplot, "cholesterol", shrink=0.8, alpha=0.5)
sea.add_legend()

colors = ['#ff99cc', '#66b3ff']

fig, axes = plt.subplots(1, 2, figsize=(15, 5), sharey=True)

fig.suptitle('Smoke and Alcohol Use by Gender', fontsize=16)

sns.countplot(ax=axes[0], x=df.smoke, hue=df.gender, palette=colors)
axes[0].set_title("Smoke Use by Gender", fontsize=14)
axes[0].set_xlabel("Smoke", fontsize=12)
axes[0].set_ylabel("Count", fontsize=12)
axes[0].legend(title="Gender")

sns.countplot(ax=axes[1], x=df.alco, hue=df.gender, palette=colors)
axes[1].set_title("Alcohol Use by Gender", fontsize=14)
axes[1].set_xlabel("Alcohol", fontsize=12)
axes[1].set_ylabel("")
axes[1].legend(title="Gender")

for ax in axes:
    for p in ax.patches:
        ax.annotate(format(p.get_height(), '.0f'),
                    (p.get_x() + p.get_width() / 2., p.get_height()),
                    ha = 'center', va = 'center',
                    xytext = (0, 5),
                    textcoords = 'offset points')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

df['gluc']=df['gluc'].replace({1: 'normal', 2: 'above normal', 3: 'well above normal' })

colors = ['#ff99cc', '#66b3ff']

cross_tab = pd.crosstab(df['gluc'], df['cardio'])

ax = cross_tab.plot(kind='bar', color=colors, figsize=(10, 6))

plt.title('Relationship between Glucose and Cardiovascular Disease', fontsize=16)
plt.xlabel('Glucose Level', fontsize=14)
plt.ylabel('Count', fontsize=14)

plt.legend(title='Cardiovascular Disease', labels=['No Cardiovascular Disease', 'Cardiovascular Disease'], fontsize=12)

for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'),
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha = 'center', va = 'center',
                xytext = (0, 5),
                textcoords = 'offset points',
                fontsize=10)

plt.xticks(rotation=0)
plt.tight_layout()

plt.show()

df['bmi'] = df['weight'] / ((df['height'] / 100) ** 2)

print(df[['weight', 'height', 'bmi']].head())

plt.figure(figsize=(10, 6))
ax = sns.histplot(df['bmi'], bins=30, kde=True, color='skyblue')

for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='bottom', xytext=(0, 5), textcoords='offset points')

plt.title('Distribution of BMI')
plt.xlabel('BMI')
plt.ylabel('Number of Individuals')

plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='cardio', y='bmi', data=df, palette='Set2')
plt.title('BMI vs. Cardiovascular Disease')
plt.xlabel('Cardiovascular Disease Status')
plt.ylabel('BMI')
plt.xticks([0, 1], ['No Cardiovascular Disease', 'With Cardiovascular Disease'])
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x='age', y='bmi', data=df, hue='gender', palette='Set1')
plt.title('BMI vs. Age')
plt.xlabel('Age')
plt.ylabel('BMI')
plt.legend(title='Gender')
plt.show()

from scipy.stats import ttest_ind

bmi_cardio_0 = df[df['cardio'] == 0]['bmi']
bmi_cardio_1 = df[df['cardio'] == 1]['bmi']

t_stat, p_value = ttest_ind(bmi_cardio_0, bmi_cardio_1)
print("T-statistic:", t_stat)
print("P-value:", p_value)

if p_value < 0.05:
    print("There is a significant difference in BMI between individuals with and without cardiovascular disease.")
else:
    print("There is no significant difference in BMI between individuals with and without cardiovascular disease.")

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.boxplot(x='cardio', y='bmi', data=df, palette='Set2')
plt.title('BMI by Cardiovascular Disease Status')
plt.xlabel('Cardiovascular Disease')
plt.ylabel('BMI')
plt.xticks([0, 1], ['No Cardio', 'With Cardio'])
plt.show()

df['bp_ratio'] = df['ap_hi'] / df['ap_lo']

print(df.head())

plt.figure(figsize=(10, 6))
sns.histplot(df['bp_ratio'], bins=30, kde=True, color='skyblue')
plt.title('Distribution of Blood Pressure Ratio (Systolic / Diastolic)')
plt.xlabel('Blood Pressure Ratio (Systolic / Diastolic)')
plt.ylabel('Frequency')
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='cardio', y='bp_ratio', data=df, palette='Set2')
plt.title('Blood Pressure Ratio by Cardiovascular Disease')
plt.xlabel('Cardiovascular Disease')
plt.ylabel('Blood Pressure Ratio (Systolic / Diastolic)')
plt.xticks([0, 1], ['No Cardio', 'With Cardio'])
plt.show()

# Create a box plot to visualize the distribution of blood pressure ratios by gender and cardiovascular disease
plt.figure(figsize=(10, 6))

# Use seaborn's boxplot function
sns.boxplot(x='gender', y='bp_ratio', data=df, hue='cardio', palette='Set1')

# Add title and labels
plt.title('Blood Pressure Ratio by Gender and Cardiovascular Disease')
plt.xlabel('Gender')
plt.ylabel('Blood Pressure Ratio (Systolic / Diastolic)')

# Add legend with appropriate labels
plt.legend(title='Cardiovascular Disease', labels=['No Cardio', 'With Cardio'])

# Show the plot
plt.show()

import matplotlib.pyplot as plt

alpha = 0.05

plt.figure(figsize=(6, 4))
plt.bar(['P-value'], [p_value], color='skyblue', alpha=0.7)

plt.axhline(y=alpha, color='red', linestyle='--', label='Significance Level')

plt.title('Association between Blood Pressure Ratios and Cardiovascular Disease')
plt.ylabel('P-value')
plt.ylim(0, 0.1)
plt.legend()

plt.text(0, p_value, f'p = {p_value:.4f}', ha='center', va='bottom')

# Indicate significance
if p_value < alpha:
    plt.text(0, alpha, 'Significant', ha='center', va='bottom', color='green')
else:
    plt.text(0, alpha, 'Not Significant', ha='center', va='bottom', color='red')

plt.show()

def classify_blood_pressure(ap_hi, ap_lo):
    if ap_hi < 120 and ap_lo < 80:
        return 'Normal'
    elif 120 <= ap_hi < 130 and ap_lo < 80:
        return 'Elevated'
    elif 130 <= ap_hi < 140 or 80 <= ap_lo < 90:
        return 'Hypertension Stage 1'
    elif ap_hi >= 140 or ap_lo >= 90:
        return 'Hypertension Stage 2'
    else:
        return 'Unknown'

df['blood_pressure_category'] = df.apply(lambda row: classify_blood_pressure(row['ap_hi'], row['ap_lo']), axis=1)

blood_pressure_distribution = df.groupby(['blood_pressure_category', 'cardio']).size().unstack(fill_value=0)
print(blood_pressure_distribution)

plt.figure(figsize=(10, 6))
ax = sns.countplot(data=df, x='blood_pressure_category', hue='cardio', palette='Set2')

for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'),
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha = 'center', va = 'center',
                xytext = (0, 5),
                textcoords = 'offset points')

plt.title('Distribution of Cardiovascular Disease Across Blood Pressure Categories')
plt.xlabel('Blood Pressure Category')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.legend(title='Cardiovascular Disease', labels=['No Cardio', 'With Cardio'])
plt.show()

def categorize_activity(activity):
    if activity == 0:
        return 'Sedentary'
    elif activity == 1:
        return 'Moderately Active'
    elif activity == 2:
        return 'Highly Active'
    else:
        return 'Unknown'

df['activity_category'] = df['active'].apply(categorize_activity)

plt.figure(figsize=(10, 6))
ax = sns.countplot(data=df, x='activity_category', hue='cardio', palette='Set2')
plt.title('Distribution of Cardiovascular Disease Across Physical Activity Categories')
plt.xlabel('Physical Activity Category')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.legend(title='Cardiovascular Disease', labels=['No Cardio', 'With Cardio'])

for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'),
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha = 'center', va = 'center',
                xytext = (0, 5),
                textcoords = 'offset points')

plt.show()

# Define weights for each feature
weights = {
    'smoke': 0.3,
    'alco': 0.3,
    'active': 0.4
}

# Normalize each feature
df['smoke_normalized'] = df['smoke'] / df['smoke'].max()
df['alco_normalized'] = df['alco'] / df['alco'].max()
df['active_normalized'] = df['active'] / df['active'].max()

# Calculate the composite index
df['composite_index'] = (
    weights['smoke'] * df['smoke_normalized'] +
    weights['alco'] * df['alco_normalized'] +
    weights['active'] * df['active_normalized']
)

# Optional: Round the composite index to make it more interpretable
df['composite_index'] = df['composite_index'].round(2)

# Visualize the distribution of the composite index across cardiovascular disease categories
plt.figure(figsize=(10, 6))
ax = sns.histplot(data=df, x='composite_index', hue='cardio', palette='Set2', kde=True)
plt.title('Distribution of Composite Index Across Cardiovascular Disease Categories')
plt.xlabel('Composite Index')
plt.ylabel('Frequency')
plt.legend(title='Cardiovascular Disease', labels=['No Cardio', 'With Cardio'])

# Annotate the count on top of each bar
for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'),
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='bottom',
                xytext=(0, 5),
                textcoords='offset points')

plt.show()

# Additional comments below the graph
# Lower composite index values indicate healthier lifestyle habits
# Higher composite index values indicate unhealthier lifestyle habits

# Create the interaction feature (product of age and weight)
df['age_weight_interaction'] = df['age'] * df['weight']

# Optional: Normalize the interaction feature
df['age_weight_interaction_normalized'] = (df['age_weight_interaction'] - df['age_weight_interaction'].min()) / (df['age_weight_interaction'].max() - df['age_weight_interaction'].min())

# Visualize the distribution of the interaction feature
plt.figure(figsize=(8, 5), dpi=100)
sns.histplot(df['age_weight_interaction_normalized'], bins=20, kde=True, color='skyblue')
plt.title('Distribution of Age-Weight Interaction')
plt.xlabel('Age-Weight Interaction (Normalized)')
plt.ylabel('Frequency')
plt.show()

# Calculate pulse pressure
df['pulse_pressure'] = df['ap_hi'] - df['ap_lo']

# Calculate mean arterial pressure (MAP)
df['mean_arterial_pressure'] = (df['ap_lo'] + 2 * df['ap_hi']) / 3

# Calculate variability in blood pressure over time
# You can use standard deviation or other measures
df['blood_pressure_variability'] = df[['ap_hi', 'ap_lo']].std(axis=1)

# Visualize the distribution of these features
plt.figure(figsize=(10, 6))
sns.histplot(df['pulse_pressure'], bins=30, kde=True, color='skyblue', label='Pulse Pressure')
sns.histplot(df['mean_arterial_pressure'], bins=30, kde=True, color='orange', label='Mean Arterial Pressure')
sns.histplot(df['blood_pressure_variability'], bins=30, kde=True, color='green', label='Blood Pressure Variability')
plt.title('Distribution of Heart Rate Variability Features')
plt.xlabel('Feature Value')
plt.ylabel('Frequency')
plt.legend()
plt.show()

df.isnull().sum()

plt.figure(figsize=(15, 10))
plt.title('Box Plot by Cardiovascular Disease')
sns.boxplot(x='cardio', y='age', data=df, palette='pastel')
plt.xlabel('Cardiovascular Disease', fontsize=12)
plt.ylabel('Age', fontsize=12)
plt.xticks(ticks=[0, 1], labels=['No Cardio', 'Cardio'], fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

df.isnull().sum()

df

# Reverse replacements for 'gender' column
df['gender'].replace({'Male': 1, 'female': 2}, inplace=True)

# Reverse replacements for 'cardio' column
df['cardio'].replace({'No Cardio': 0, 'With Cardio': 1}, inplace=True)

df

!pip install --upgrade scikit-learn

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split, KFold
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.ensemble import RandomForestClassifier
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping

# Assume df is your dataframe and it has already been prepared

# Separate features and target variable
X_cont = df[['age', 'height', 'weight', 'ap_hi', 'ap_lo', 'bmi', 'bp_ratio', 'age_weight_interaction', 'pulse_pressure', 'mean_arterial_pressure', 'blood_pressure_variability']]  # Continuous features
X_cat = df[['gender', 'cholesterol', 'gluc', 'smoke', 'alco', 'active', 'cholesterol_transformed', 'blood_pressure_category', 'activity_category']]  # Categorical features
y = df['cardio']  # Target variable

# Encode categorical variables
encoder = OneHotEncoder(drop='first')
X_cat_encoded = encoder.fit_transform(X_cat).toarray()

# Combine continuous and encoded categorical features
X = np.concatenate((X_cont, X_cat_encoded), axis=1)

# Replace infinite values with NaN
X[np.isinf(X)] = np.nan

# Drop rows with NaN values
mask = ~np.isnan(X).any(axis=1)
X = X[mask]
y = y[mask]

# Convert X and y to numpy arrays
X = X.astype(float)
y = y.to_numpy()

# Train a Random Forest model to get feature importances
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X, y)

# Get feature importances
importances = rf.feature_importances_

# Create a DataFrame for feature importances
feature_names = np.concatenate((X_cont.columns, encoder.get_feature_names_out()))
importance_df = pd.DataFrame({'Feature': feature_names, 'Importance': importances})

# Sort features by importance
importance_df = importance_df.sort_values(by='Importance', ascending=False)

# Select the top N important features (e.g., top 10 features)
top_features = importance_df['Feature'].head(10).values
top_feature_indices = [list(feature_names).index(feature) for feature in top_features]

# Select only the top N important features for X
X_top = X[:, top_feature_indices]

# Initialize k-fold cross-validation
kf = KFold(n_splits=5, shuffle=True, random_state=42)

# List to store the accuracy of each fold
fold_accuracies = []

for train_index, val_index in kf.split(X_top):
    X_train, X_val = X_top[train_index], X_top[val_index]
    y_train, y_val = y[train_index], y[val_index]

    # Standardize the features
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_val_scaled = scaler.transform(X_val)

    # Define the model
    model = Sequential([
        Dense(128, activation='relu', input_shape=(X_train_scaled.shape[1],)),
        BatchNormalization(),
        Dense(64, activation='relu'),
        Dropout(0.2),
        Dense(32, activation='relu'),
        Dense(16, activation='relu'),
        Dropout(0.2),
        Dense(1, activation='sigmoid')
    ])

    # Compile the model
    optimizer = Adam(learning_rate=0.001)
    model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

    # Early stopping
    early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

    # Train the model
    history = model.fit(X_train_scaled, y_train, epochs=100, batch_size=32, validation_data=(X_val_scaled, y_val), callbacks=[early_stopping], verbose=0)

    # Evaluate the model on the validation set
    val_loss, val_accuracy = model.evaluate(X_val_scaled, y_val, verbose=0)
    fold_accuracies.append(val_accuracy)

# Calculate the average accuracy across all folds
average_accuracy = np.mean(fold_accuracies)
print("Average Accuracy across folds:", average_accuracy)

# After k-fold cross-validation, you can train on the entire training data and evaluate on the test data
# Split the data into training and test sets for final evaluation
X_train, X_test, y_train, y_test = train_test_split(X_top, y, test_size=0.15, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Define the final model
final_model = Sequential([
    Dense(128, activation='relu', input_shape=(X_train_scaled.shape[1],)),
    BatchNormalization(),
    Dense(64, activation='relu'),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dense(16, activation='relu'),
    Dropout(0.2),
    Dense(1, activation='sigmoid')
])

# Compile the final model
final_model.compile(optimizer=Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])

# Early stopping
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

# Train the final model
final_model.fit(X_train_scaled, y_train, epochs=100, batch_size=32, validation_split=0.15, callbacks=[early_stopping], verbose=2)

# Evaluate the final model
test_loss, test_accuracy = final_model.evaluate(X_test_scaled, y_test, verbose=0)
print("Test Loss:", test_loss)
print("Test Accuracy:", test_accuracy)

# Evaluate the model
test_loss, test_accuracy = model.evaluate(X_test_scaled, y_test)
print("Test Loss:", test_loss)
print("Test Accuracy:", test_accuracy)

# Generate predictions on the test set
y_pred_probs = model.predict(X_test_scaled)
y_pred = (y_pred_probs > 0.5).astype(int)

# Generate classification report
report = classification_report(y_test, y_pred)
print("Classification Report:")
print(report)

# Plot training & validation loss values
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# Generate predictions on the test set
y_pred_probs = model.predict(X_test_scaled)
y_pred = (y_pred_probs > 0.5).astype(int)

# Compute the confusion matrix
cm = confusion_matrix(y_test, y_pred)

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['No Cardio', 'Cardio'],
            yticklabels=['No Cardio', 'Cardio'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

X = df.drop(['cardio'], axis=1)
y = df['cardio']

categorical_cols = ['gender', 'cholesterol', 'gluc']

numeric_transformer = 'passthrough'
categorical_transformer = OneHotEncoder(drop='first')

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, X.select_dtypes(include=['int64', 'float64']).columns),
        ('cat', categorical_transformer, categorical_cols)
    ])

rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)

pipeline = Pipeline(steps=[('preprocessor', preprocessor), ('classifier', rf_classifier)])

pipeline.fit(X, y)

feature_importances = pipeline.named_steps['classifier'].feature_importances_

encoded_categorical_cols = pipeline.named_steps['preprocessor'].named_transformers_['cat'].get_feature_names_out(input_features=categorical_cols)
feature_names = list(X.select_dtypes(include=['int64', 'float64']).columns) + list(encoded_categorical_cols)

feature_importance_df = pd.DataFrame({'Feature': feature_names, 'Importance': feature_importances})
feature_importance_df = feature_importance_df.sort_values(by='Importance', ascending=False)

plt.figure(figsize=(10, 6))
sns.barplot(data=feature_importance_df, x='Importance', y='Feature', palette='viridis')
plt.title('Feature Importance Analysis')
plt.xlabel('Importance')
plt.ylabel('Feature')
plt.show()